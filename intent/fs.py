# intent/fs.py
from __future__ import annotations

import os
import tempfile
from dataclasses import dataclass
from pathlib import Path
from typing import Literal

GENERATED_MARKER = "# GENERATED BY intent"


@dataclass(frozen=True)
class OwnershipError(RuntimeError):
    path: Path
    message: str

    def __str__(self) -> str:
        return f"{self.path}: {self.message}"


def _is_tool_owned(text: str, marker: str = GENERATED_MARKER) -> bool:
    return any(line.strip() == marker for line in text.splitlines())


def _strip_generated_header(text: str, marker: str = GENERATED_MARKER) -> str:
    lines = text.splitlines()
    if not lines:
        return ""
    start = 0
    if lines and lines[0].strip() == marker:
        start = 1
        if len(lines) > 1 and lines[1].strip() == "# DO NOT EDIT":
            start = 2
        while start < len(lines) and not lines[start].strip():
            start += 1
    return "\n".join(lines[start:]).strip()


def _atomic_write_text(path: Path, content: str, encoding: str = "utf-8") -> None:
    """
    Write content atomically: write to a temp file in the same directory, then replace.
    This avoids partially-written files if the process is interrupted.
    """
    directory = path.parent
    directory.mkdir(parents=True, exist_ok=True)

    fd, tmp_name = tempfile.mkstemp(prefix=".intent.", dir=str(directory))
    tmp_path = Path(tmp_name)

    try:
        with os.fdopen(fd, "w", encoding=encoding, newline="\n") as f:
            f.write(content)
        os.replace(tmp_path, path)  # atomic on POSIX when same filesystem
    finally:
        if tmp_path.exists():
            try:
                tmp_path.unlink()
            except OSError:
                pass


def write_generated_file(
    path: Path,
    content: str,
    marker: str = GENERATED_MARKER,
    mode: Literal["strict", "adopt", "force"] = "strict",
) -> bool:
    """
    Write a tool-generated file safely.

    Returns True if the file was written/updated, False if no change.

    Safety rules:
    - strict: refuse to overwrite existing non-tool-owned files.
    - adopt: overwrite non-tool-owned files only if content matches generated body.
    - force: overwrite existing non-tool-owned files.
    - Refuse to write if the *new* content does not include the marker.
    - If content is identical, do nothing (idempotent).
    """
    if marker not in content:
        raise ValueError(f"Refusing to write {path}: generated content missing marker {marker!r}")

    if path.exists():
        existing = path.read_text(encoding="utf-8")
        if not _is_tool_owned(existing, marker=marker):
            if mode == "strict":
                raise OwnershipError(
                    path=path,
                    message=f"Refusing to overwrite: file is not marked as generated ({marker})",
                )
            if mode == "adopt":
                existing_body = _strip_generated_header(existing, marker=marker)
                generated_body = _strip_generated_header(content, marker=marker)
                if existing_body != generated_body:
                    raise OwnershipError(
                        path=path,
                        message="Refusing to adopt: existing content differs (use --force)",
                    )
        if existing == content:
            return False
        _atomic_write_text(path, content)
        return True

    _atomic_write_text(path, content)
    return True
